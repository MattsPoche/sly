(define (displayln x) (display x)(display "\n"))

(define (caar p)
  (car (car p)))

(define (cdar p)
  (cdr (car p)))

(define (cadr p)
  (car (cdr p)))

(define (cddr p)
  (cdr (cdr p)))

(define (caddr p)
  (car (cddr p)))

(define (cdddr p)
  (cdr (cddr p)))

(define (cadddr p)
  (car (cdddr p)))

(define (zero? n) (= n 0))

(define (fold-left f z xs)
  (if (null? xs)
	  z
	  ((lambda (x xs)
		 (fold-left f (f x z) xs))
	   (car xs) (cdr xs))))

(define (fold-right f z xs)
  (if (null? xs)
	  z
	  ((lambda (x xs)
		 (f x (fold-right f z xs)))
	   (car xs) (cdr xs))))

(define (contains xs x)
  (if (null? xs)
	  #f
	  (if (equal? (car xs) x)
		  #t
		  (contains (cdr xs) x))))

(define (remove xs x)
  (if (null? xs)
	  xs
	  (if (equal? (car xs) x)
		  (cdr xs)
		  (cons (car xs)
				(remove (cdr xs) x)))))

(define (append xs . rest)
  (define (helper xs rest)
	  (if (pair? rest)
		  (helper (fold-right cons (car rest) xs) (cdr rest))
		  xs))
  (helper xs rest))

(define (reverse ls)
  (fold-left cons '() ls))

(define (last-pair xs)
  (if (pair? (cdr xs))
	  (last-pair (cdr xs))
	  xs))

(define (list-copy xs)
  (fold-right cons '() xs))

(define (length xs)
  (fold-left (lambda (x y) (+ y 1)) 0 xs))

(define (list-ref xs i)
  (if (null? xs)
	  '**END-OF-LIST**
	  (if (zero? i)
		  (car xs)
		  (list-ref (cdr xs) (- i 1)))))

(define (count val xs)
  (fold-right
   (lambda (x c) (if (equal? x val) (+ c 1) c))
   0 xs))

(define (argmax f xs)
  (define max 0)
  (define x 0)
  (define item '())
  (define (loop f xs)
	(if (null? xs)
		item
		(begin (set! x (f (car xs)))
			   (if (> x max)
				   (begin
					 (set! max x)
					 (set! item (car xs)))
				   (void))
			   (loop f (cdr xs)))))
  (loop f xs))

(define (*heads* xs)
  (if (null? xs)
	  '()
	  (cons (caar xs) (*heads* (cdr xs)))))

(define (*tails* xs)
  (if (null? xs)
	  '()
	  (cons (cdar xs) (*tails* (cdr xs)))))

(define (map f . xs)
  (if (null? (car xs))
	  '()
	  (cons (apply f (*heads* xs))
			(apply map f (*tails* xs)))))

(define (for-each f . xs)
  (if (null? (car xs))
	  '()
	  (begin
		(apply f (*heads* xs))
		(apply for-each f (*tails* xs)))))

(display "FINISHED FILE: sly-lib/list.sly\n")
