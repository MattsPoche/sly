;;; Basic list operations

(provide displayln
		 display-syntax
		 caar
		 cdar
		 cadr
		 cddr
		 caddr
		 cdddr
		 cadddr
		 zero?
		 fold-left
		 fold-right
		 member
		 memv
		 memq
		 remove
		 append
		 reverse
		 last-pair
		 list-copy
		 length
		 list-ref
		 count
		 argmax
		 map
		 for-each
		 generate-temporaries
		 take
		 assoc
		 alist-cons
		 alist-copy
		 plist-get
		 plist-put
		 provide)

(define (displayln x) (display x)(display "\n"))

(define (display-syntax p s)
  (if p	(display p) (void))
  (displayln (syntax->datum s)))

(define (caar p)
  (car (car p)))

(define (cdar p)
  (cdr (car p)))

(define (cadr p)
  (car (cdr p)))

(define (cddr p)
  (cdr (cdr p)))

(define (caddr p)
  (car (cddr p)))

(define (cdddr p)
  (cdr (cddr p)))

(define (cadddr p)
  (car (cdddr p)))

(define (zero? n) (= n 0))

(define (fold-left f z xs)
  (if (null? xs)
	  z
	  ((lambda (x xs)
		 (fold-left f (f x z) xs))
	   (car xs) (cdr xs))))

(define (fold-right f z xs)
  (if (null? xs)
	  z
	  ((lambda (x xs)
		 (f x (fold-right f z xs)))
	   (car xs) (cdr xs))))

(define (member x xs . compare)
  (if (null? compare)
	  (set! compare equal?)
	  (set! compare (car compare)))
  (if (null? xs)
	  #f
	  (if (compare x (car xs))
		  (car xs)
		  (member x (cdr xs) compare))))

(define (memq x xs) (member x xs eq?))

(define memv member) ;; TODO: emplement `eqv?'

(define (remove xs x)
  (if (null? xs)
	  xs
	  (if (equal? (car xs) x)
		  (cdr xs)
		  (cons (car xs)
				(remove (cdr xs) x)))))

(define (append xs . rest)
  (define (helper xs rest)
	  (if (pair? rest)
		  (helper (fold-right cons (car rest) xs) (cdr rest))
		  xs))
  (helper xs rest))

(define (reverse ls)
  (fold-left cons '() ls))

(define (last-pair xs)
  (if (pair? (cdr xs))
	  (last-pair (cdr xs))
	  xs))

(define (list-copy xs)
  (fold-right cons '() xs))

(define (length xs)
  (fold-left (lambda (x y) (+ y 1)) 0 xs))

(define (list-ref xs i)
  (if (null? xs)
	  '**END-OF-LIST**
	  (if (zero? i)
		  (car xs)
		  (list-ref (cdr xs) (- i 1)))))

(define (count val xs)
  (fold-right
   (lambda (x c) (if (equal? x val) (+ c 1) c))
   0 xs))

(define (argmax f xs)
  (define max 0)
  (define x 0)
  (define item '())
  (define (loop f xs)
	(if (null? xs)
		item
		(begin (set! x (f (car xs)))
			   (if (> x max)
				   (begin
					 (set! max x)
					 (set! item (car xs)))
				   (void))
			   (loop f (cdr xs)))))
  (loop f xs))

(define (*heads* xs)
  (if (null? xs)
	  '()
	  (cons (caar xs) (*heads* (cdr xs)))))

(define (*tails* xs)
  (if (null? xs)
	  '()
	  (cons (cdar xs) (*tails* (cdr xs)))))

(define (map f . xs)
  (if (null? (car xs))
	  '()
	  (cons (apply f (*heads* xs))
			(apply map f (*tails* xs)))))

(define (for-each f . xs)
  (if (null? (car xs))
	  '()
	  (begin
		(apply f (*heads* xs))
		(apply for-each f (*tails* xs)))))

(define (generate-temporaries ids)
  (if (syntax? ids) (set! ids (syntax->list ids)) #f)
  (map (lambda (id)
		 (define x (syntax->datum id))
		 (datum->syntax id (string->symbol (string-join (list "temp" (symbol->string x)) "--"))))
	   ids))

(define (take ls n)
  (if (<= n 0)
	  '()
	  (if (null? ls)
		  (error "List out-of-bounds")
		  (cons (car ls) (take (- n 1) (cdr ls))))))

(define (assoc key alist)
  (define x '())
  (if (null? alist) '()
	  (begin
		(set! x (car alist))
		(if (equal? key (car x)) x
			(assoc key (cdr alist))))))

(define (alist-cons key datum alist)
  (cons (cons key datum) alist))

(define (alist-copy alist)
  (fold-right (lambda (x xs)
				(alist-cons (car x) (cdr x) alist))
			  '() alist))

(define (plist-get plist prop)
  (if (null? plist) '()
	  (if (if (eq? (car plist) prop) (pair? (cdr plist)) #f)
		  (cadr plist)
		  (plist-get (cdr plist) prop))))

(define (plist-put plist prop val)
  (if (null? plist)
	  (list prop val)
	  (if (if (eq? (car plist) prop) (pair? (cdr plist)) #f)
		  (append (list prop val) (cddr plist))
		  (append (list (car plist) (cadr plist))
				  (plist-put (cddr plist) prop val)))))
