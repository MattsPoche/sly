
(let* ([exports #'(_ foo bar)]
	   [s (syntax-case exports (as)
			[(_ (name as alias) rest ...)
			 #'(cons (cons 'alias name) rest ...)]
			[(_ name rest ...)
			 #'(cons (cons 'name name) rest ...)])])
  (displayln (syntax->datum s)))


;; (define-syntax make-exports-
;;   (syntax-rules (as)
;; 	[(_ (name as alias) rest ...)
;; 	 (cons (cons 'alias name) rest ...)]
;; 	[(_ name rest ...)
;; 	 (cons (cons 'name name) rest ...)]))

;; (define-syntax define-module
;;   (syntax-rules (export)
;; 	[(_ name (export exports ...) body ...)
;; 	 (define name
;; 	   (let ()
;; 		 body ...
;; 		 (make-dictionary (make-exports- exports ...))))]))

;; (define-syntax module-ref
;;   (syntax-rules ()
;; 	[(_ module id)
;; 	 (dictionary-ref module 'id)]))

;; (define-module test-module
;;   (export func1
;; 		  func2)

;;   (define (helper) (display "Hello from helper\n"))

;;   (define (func1)
;; 	(display "Hello from func1! Whats up??\n"))

;;   (define (func2)
;; 	(helper)
;; 	(display "Hello from func2! ")
;; 	(displayln (/ 420 69))))

;; ((module-ref test-module func1))
;; ((module-ref test-module func2))
;; ((module-ref test-module helper))


(display-syntax
 "((foo bar) baz buzz) => "
 (syntax-case #'((foo bar) baz buzz) ()
   [(x y z)
	(let ()
	  (display-syntax "z :: " #'z)
	  (display-syntax "y :: " #'y)
	  (display-syntax "x :: " #'x)
	  #'(z y x))]))

(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      [(_ ((p e) ...) b1 b2 ...)
	   #'(syntax-case (list e ...) ()
		   [(p ...) (let () b1 b2 ...)])])))

;; UPDATE: Appears to be working more testing needed of course ;)

(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(_ c1 c2 ...)
       (let f ([c1 #'c1] [cmore (syntax->list #'(c2 ...))])
         (if (null? cmore)
             (syntax-case c1 (else =>)
			   ;; need to check for literals in the first position
               [(else e1 e2 ...) #'(begin e1 e2 ...)]
               [(e0) #'(let ([t e0]) (if t t))]
               [(e0 => e1) #'(let ([t e0]) (if t (e1 t) (void)))]
			   ;; need to not ignore the first pattern element
               [(e0 e1 e2 ...) #'(if e0 (begin e1 e2 ...) (void))])
             (with-syntax ([rest (f (car cmore) (cdr cmore))])
               (syntax-case c1 (=>)
                 [(e0) #'(let ([t e0]) (if t t rest))]
                 [(e0 => e1) #'(let ([t e0]) (if t (e1 t) rest))]
                 [(e0 e1 e2 ...)
                  #'(if e0 (begin e1 e2 ...) rest)]))))])))

(displayln (syntax->datum (syntax-case #'(foo bar baz) ()
							[(x y z)
							 #'(z y x)])))

(cond [(> 69 420) (displayln "foo")]
	  [#t (displayln "bar")])

(define-syntax define-a
  (lambda (form)
	(syntax-case form ()
	  [(define-a x)
	   (with-syntax ([a (datum->syntax #'define-a 'a)])
		 #'(define a x))])))

(define-a 69)
(displayln a)

(define-syntax (define-macro form)
  (syntax-case form ()
      [(define-macro (name . pattern) e e* ...)
       #'(define-syntax (name form)
           (syntax-case form ()
             [(name . pattern)
              (begin e e* ...)]))]))

(define-macro (swap! x y)
  #'(let ((tmp x))
	  (set! x y)
	  (set! y tmp)))

(define x 69)
(define y 420)

(swap! x y)
(displayln x)
(displayln y)

(define-macro (my-let ((var value) ...) e e* ...)
  #'((lambda (var ...) e e* ...) value ...))

(my-let ((x 32)
		 (y 69))
		(displayln (* x y)))
