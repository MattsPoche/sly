(require "sly-lib/base.sly")

(import test-module)

(test-module#fun)
(test-module#fun2 "My name is Cpt. Coolio")

(define& (cat s1 s2 (delim " "))
  (string-join (list s1 s2) delim))

(displayln (cat "hello" "world" 'delim " => "))
(displayln (cat "foo" "bar"))

(define (values . things)
  (call/cc  (lambda (cc) (apply cc things))))

(define test (lambda ()
			   (display "(* (values 420) 2) => ")
			   (displayln (* (values 420) 2))))

(test)
(display "(values 69) => ")
(displayln (values 69))
(displayln (- (*)))


(let ([str (call-with-values
			   (lambda ()
				 (values "This" "is" "Bob"))
			 (lambda (x y z)
			   (displayln x)
			   (displayln y)
			   (displayln z)
			   (string-join (list x y z) " ")))])
  (displayln str))

(displayln
 (letrec ([even? (lambda (n)
				   (if (zero? n)
					   #t
					   (odd? (- n 1))))]
          [odd? (lambda (n)
                  (if (zero? n)
                      #f
                      (even? (- n 1))))])
   (even? 88)))

(letrec* ([p (lambda (x)
			   (+ 1 (q (- x 1))))]
		  [q (lambda (y)
			   (if (zero? y)
				   0
				   (+ 1 (p (- y 1)))))]
		  [x (p 5)]
		  [y x])
  (displayln y))

(define (add-three a b c)
  (+ a b c))

(let ()
  (displayln (apply + '(1 2 3)))
  (displayln (apply + 1 2 '(3))))

(displayln (list->vector '(a b c d)))

(define-syntax decorate
  (syntax-rules ()
	[(_ fn decorator)
	 (set! fn (decorator fn))]))

(define-syntax define-with-decorator
  (syntax-rules ()
	[(_ decorator (name . formals) body ...)
	 (define name (decorator (lambda formals body ...)))]))

(define (do-twice fn)
  (lambda args
	(apply fn args)
	(apply fn args)))

(define-with-decorator do-twice
  (say-hello)
  (displayln "hello"))

(say-hello)

(define-syntax set-m!
  (syntax-rules (dictionary-ref)
	[(_ (dictionary-ref dict key) value)
	 (dictionary-set! dict key value)]))

(define dict (make-dictionary))
(displayln dict)
(set-m! dict#member 69)
(set-m! dict#say-hello "i like turtles")
(displayln dict)
(displayln dict#member)
(displayln dict#say-hello)

(define <employee> (make-dictionary))
(set-m! <employee>#__meta__ (make-dictionary))
(set-m! <employee>#new
		(lambda (name salary)
		  (let ([employee (make-dictionary)])
			(set-m! employee#__meta__ <employee>#__meta__)
			(set-m! employee#name name)
			(set-m! employee#salary salary)
			employee)))

(define (employee? thing)
  (and (dictionary? thing)
	   (eq? thing#__meta__ <employee>#__meta__)))

(define bob (<employee>#new "bob" 69000))

(displayln bob)

(displayln (employee? (make-dictionary)))

;; (call-with-values (lambda () (values 69 420))
;;   (lambda (a b)
;; 	(displayln a)
;; 	(displayln b)))

(define <record-type> (make-dictionary))

(define <promise> (make-dictionary))
(set-m! <promise>#__meta__ <record-type>)
(set-m! <promise>#new
		(lambda (p)
		  (let ([new-promise (make-dictionary)])
			(set-m! new-promise#__meta__ <promise>)
			(set-m! new-promise#p
					(let ([val #f]
						  [set? #f])
					  (lambda ()
						(unless set?
						  (let ([x (p)])
							(unless set?
							  (begin (set! val x)
									 (set! set? #t)))))
						val)))
			new-promise)))

(define (record-type? thing)
  (and (dictionary? thing)
	   (eq? thing#__meta__ <record-type>)))

(define (record? thing)
  (and (dictionary? thing)
	   (thing#__meta__)
	   (eq? thing#__meta__#__meta__ <record-type>)))

(define (promise? thing)
  (and (dictionary? thing)
	   (eq? thing#__meta__ <promise>)))

(define (force p)
  (if (promise? p) (p#p)
	  (error "Type error expected <promise>")))

(define-syntax delay
  (syntax-rules ()
	[(_ exp) (<promise>#new (lambda () exp))]))

(let ([p (delay (+ 69 420))])
  (displayln (force p))
  (displayln (force p))
  (displayln (force p))
  (displayln (dictionary->alist p)))

(define (stream-car s) (car (force s)))
(define (stream-cdr s) (cdr (force s)))

(define (make-stream proc initial-state)
  (delay (proc initial-state)))

(define counters
  (let next ([n 1])
	(delay (cons n (next (+ n 1))))))

(displayln (stream-car counters))
(displayln (stream-car (stream-cdr counters)))

(define (string . chars)
  (let ([s (make-string (length chars))])
	(let loop ([i 0]
			   [chars chars])
	  (if (null? chars) s
		  (begin
			(string-set! s i (car chars))
			(loop (+ i 1) (cdr chars)))))))

(define (substring s1 m n)
  (let ((s2 (make-string (- n m))))
    (do ((j 0 (+ j 1)) (i m (+ i 1)))
        ((= i n) s2)
      (string-set! s2 j (string-ref s1 i)))))

(define (string->list s)
  (do ((i (- (string-length s) 1) (- i 1))
       (ls '() (cons (string-ref s i) ls)))
      ((< i 0) ls)))

(define (list->string xs) (apply string xs))

(let ([s "hi there"])
  (displayln (substring s 0 1))
  (displayln (substring s 3 6))
  (displayln (substring s 5 5))
  (displayln (substring s 0 (string-length s)))
  (displayln (string->list s))
  (displayln (list->string (string->list s))))

(displayln (call-with-values
			   (lambda ()
				 (values 1 2 3 4 5))
			 (lambda (a b c d e)
			   (* a b c d e))))
